#include <Wire.h>
#include <BH1750.h>
#include <DHT.h>
#include <OneWire.h>
#include <DS18B20.h>
#include <Servo.h>

// --- sensor settings ---

// Temp, humidity
#define DHTPIN 7
#define DHTTYPE DHT22
DHT dht(DHTPIN, DHTTYPE);

// CO2
byte cmd[9] = { 0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79 };
byte response[9];

// Weight
#define DOUT 14
#define SCK 15

BH1750 lightMeter;

// EC
#define ECpin A2

// pH
#define PHpin A1

// Water temp
DS18B20 DS18B20_Sensor(4);

// Reed switch
#define REEDswitch 10
int pastStat = 0;
int count = 0;


int PUL = 5;
int DIR = 6;
int ENA = 8;

Servo Servo_1;
int Servo_1_Pin = 9; //서보 디지털핀 지정 필요
float Servo_1_Close = 10.0; //서보 영점 설정
float Servo_1_Open = 70.0; //서보 목표 각도 설정

// --- setup ---
void setup() {
  Serial.begin(9600);
  while (!Serial) {
    delay(10);
  }

  Serial1.begin(9600);      // CO2
  dht.begin();              // Temp & Humidity
  Wire.begin();             // Light
  lightMeter.begin();       // Light
  pinMode(SCK, OUTPUT);     // HX711
  pinMode(DOUT, INPUT);     // HX711
  pinMode(ECpin, INPUT);    // EC
  pinMode(PHpin, INPUT);    // pH raw
  pinMode(REEDswitch, INPUT_PULLUP);  // Reed switch
  pinMode(PUL, OUTPUT);
  pinMode(DIR, OUTPUT);
  pinMode(ENA, OUTPUT);
  digitalWrite(DIR,HIGH);
  digitalWrite(ENA,HIGH);
  digitalWrite(PUL,HIGH);
  Servo_1.attach(Servo_1_Pin);
  Servo_1.write(Servo_1_ZeroPoint);
}

void loop() {
  get_data();

  if (Serial.available())
  {
    char c = Serial.read();
    Serial.println(c);
    if (c=='1')
    {
      close_servo();
    }
    else if (c=='2')
    {
      open_servo();
    }
    else if (c=='3')
    {
      rotate_left();
    }
    else if (c=='4')
    {
      rotate_right();
    }
  }

  delay(100);  // __단위 마다 전체 측정 과정 반복
}

// SERVO_1 FUNCTION //
void close_servo() {
  Serial.println("Servo: Close");
  Servo_1.write(Servo_1_Close);
}

void open_servo() {
  Serial.println("Servo: Open");
  Servo_1.write(Servo_1_Open);
}

void rotate_left()
{
  Serial.println("Rotating stand");
  for (int i=0; i<600; i++)    //반시계방향으로 90도 회전
  {
    digitalWrite(DIR,HIGH);
    digitalWrite(ENA,HIGH);
    digitalWrite(PUL,HIGH);
    delayMicroseconds(10000);
    digitalWrite(PUL,LOW);
    delayMicroseconds(10000);
  }
  delay(1000);
}

void rotate_right()
{
  Serial.println("Rotating stand");
  for (int i=0; i<600; i++)   //시계방향으로 90도 회전
  {
    digitalWrite(DIR,LOW);
    digitalWrite(ENA,HIGH);
    digitalWrite(PUL,HIGH);
    delayMicroseconds(10000);
    digitalWrite(PUL,LOW);
    delayMicroseconds(10000);
  }
  delay(1000);
}

void get_data()
{
  Serial1.write(cmd, 9);
  Serial.println("Receiving data:");

  if (Serial1.available() >= 9) {
    Serial1.readBytes(response, 9);

    if (response[0] == 0xFF && response[1] == 0x86) {
      byte checksum = calculateChecksum(response);
      if (response[8] == checksum){
        int co2_ppm = response[2] * 256 + response[3];
        float temperature = dht.readTemperature();
        float humidity = dht.readHumidity();
        float lux = lightMeter.readLightLevel();
        long raw_weight = readRaw();


        float raw_EC = analogRead(ECpin);
        float EC_voltage = raw_EC * (5.0 / 1023.0);
        int raw_PH = analogRead(PHpin);
        float PH_voltage = raw_PH * (5.0 / 1023.0);
        float water_temp = DS18B20_Sensor.getTempC();
        float insolation = ((lux / 54) * (1 / 4.57));

        int curStat = digitalRead(REEDswitch);
        if (pastStat != curStat)
        {
          count++;
        }
        pastStat = curStat;

        Serial.print(temperature);
        Serial.print(",");
        Serial.print(humidity);
        Serial.print(",");
        Serial.print(co2_ppm);
        Serial.print(",");
        Serial.print(insolation);
        Serial.print(",");
        Serial.print(raw_weight);
        Serial.print(",");
        Serial.print(PH_voltage);
        Serial.print(",");
        Serial.print(EC_voltage);
        Serial.print(",");
        Serial.print(water_temp);
        Serial.print(",");
        Serial.println(count);
      }
    }
  } 
  else {
    while (Serial1.available()){
      Serial1.read();
    }
  }
}



// CO2 checksum
byte calculateChecksum(byte *packet) {
  byte checksum = 0;
  for (int i = 1; i < 8; i++) {
    checksum += packet[i];
  }
  checksum = 0xFF - checksum;
  checksum += 1;
  return checksum;
}


// read raw scale
long readRaw() {
  while (digitalRead(DOUT) == HIGH) {
    ;
  }
  long value = 0;
  for (int i = 0; i < 24; i++) {
    digitalWrite(SCK, HIGH);
    value = value << 1;
    if (digitalRead(DOUT) == HIGH) {
      value++;
    }
    digitalWrite(SCK, LOW);
  }
  for (int i = 0; i < 3; i++) {
    digitalWrite(SCK, HIGH);
    digitalWrite(SCK, LOW);
  }
  if (value & 0x800000) {
    value |= 0xFF000000;
  }
  return value;
}
